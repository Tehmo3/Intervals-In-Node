<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>DiscreteRanges.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="DateRange.html">DateRange</a><ul class='methods'><li data-type='method'><a href="DateRange.html#.fromDate">fromDate</a></li><li data-type='method'><a href="DateRange.html#.length">length</a></li></ul></li><li><a href="DiscreteRange.html">DiscreteRange</a><ul class='methods'><li data-type='method'><a href="DiscreteRange.html#.last">last</a></li><li data-type='method'><a href="DiscreteRange.html#.next">next</a></li><li data-type='method'><a href="DiscreteRange.html#.prev">prev</a></li></ul></li><li><a href="floatRange.html">floatRange</a><ul class='methods'><li data-type='method'><a href="floatRange.html#offset">offset</a></li></ul></li><li><a href="IntRange.html">IntRange</a><ul class='methods'><li data-type='method'><a href="IntRange.html#.length">length</a></li><li data-type='method'><a href="IntRange.html#offset">offset</a></li></ul></li><li><a href="Range.html">Range</a><ul class='methods'><li data-type='method'><a href="Range.html#.adjacent">adjacent</a></li><li data-type='method'><a href="Range.html#.contains">contains</a></li><li data-type='method'><a href="Range.html#.difference">difference</a></li><li data-type='method'><a href="Range.html#.empty">empty</a></li><li data-type='method'><a href="Range.html#.endsBefore">endsBefore</a></li><li data-type='method'><a href="Range.html#.endsWith">endsWith</a></li><li data-type='method'><a href="Range.html#.intersection">intersection</a></li><li data-type='method'><a href="Range.html#.isEmpty">isEmpty</a></li><li data-type='method'><a href="Range.html#.isEqual">isEqual</a></li><li data-type='method'><a href="Range.html#.isValidRange">isValidRange</a></li><li data-type='method'><a href="Range.html#.isValidScalar">isValidScalar</a></li><li data-type='method'><a href="Range.html#.leftOf">leftOf</a></li><li data-type='method'><a href="Range.html#.overlap">overlap</a></li><li data-type='method'><a href="Range.html#.replace">replace</a></li><li data-type='method'><a href="Range.html#.rightOf">rightOf</a></li><li data-type='method'><a href="Range.html#.startsAfter">startsAfter</a></li><li data-type='method'><a href="Range.html#.startsWith">startsWith</a></li><li data-type='method'><a href="Range.html#.union">union</a></li></ul></li><li><a href="StrRange.html">StrRange</a><ul class='methods'><li data-type='method'><a href="StrRange.html#.next">next</a></li><li data-type='method'><a href="StrRange.html#.prev">prev</a></li></ul></li></ul><h3>Mixins</h3><ul><li><a href="OffsetableRangeMixin.html">OffsetableRangeMixin</a><ul class='methods'><li data-type='method'><a href="OffsetableRangeMixin.html#.offset">offset</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">DiscreteRanges.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Range = require('./Range.js');
const utils = require('./utils');
const moment = require('moment');

const _internalRange = utils.namedList(['lower', 'upper', 'lowerInc', 'upperInc', 'empty']);
const _emptyInternalRange = _internalRange([null, null, false, false, true]);

class DiscreteRange extends Range {
  /**
  @class DiscreteRange
  @extends Range
  @description Discrete ranges are a subset of ranges that work
  on discrete types. This includes `int` and `datetime.date`.
  * Discrete ranges are iterable. Using: let x of IntRange.
  @param {object} settings - The settings of the range.
  @param {scalar} [settings.lower=null] - The lower end of the range
  @param {scalar} [settings.upper=null] - The upper end of the range
  @param {boolean} [settings.lowerInc=true] - ``true`` if lower end should be included in range.
  @param {boolean} [settings.upperInc=false] ``true`` if upper end should be included in range.
  */
  constructor(step, settings = {}) {
    super(settings);
    this.step = step;
    let lb = this.lower;
    if (this.lower &amp;&amp; !this.lowerInc) {
      lb = this.next(lb);
    }

    let ub = this.upper;
    if (this.upper &amp;&amp; this.upperInc) {
      ub = this.next(ub, this.step, settings.type);
    }
    if (this.lower &amp;&amp; this.upper &amp;&amp; lb >= ub) {
      this._range = _emptyInternalRange;
      this.replace({ upper: null, lower: null, lowerInc: false, upperInc: false });
    } else {
      this._range = _internalRange([lb, ub, true, false, false]);
      this.replace({ upper: ub, lower: lb, lowerInc: true, upperInc: false });
    }
  }
  /**
  @memberof DiscreteRange
  @method next
  @description Increment the given value with the step defined for this class.
  @param {scalar} curr -Value to increment
  @param {scalar} step - How much to step by each time. OPTIONAL (defaults to
  whatever is appropriate for the current range, for ints it is 1).
  @returns {scalar}
  */
  next(curr, step = 1, type = '') {
    if (this) {
      step = this.step ? this.step : step;
      type = this.type ? this.type : type;
    }
    if (type === 'date') { return curr.add(1, step); }
    return curr + step;
  }

  [Symbol.iterator]() {
    const nextFunc = this.next;
    const last = this.last();
    const step = this.step;
    const type = this.type;
    let start = this.prev(this.lower, step, type);
    const iterator = {
      next() {
        start = nextFunc(start, step, type);
        const bool = type === 'date' ? start.isAfter(last) : (start) > last;
        return {
          value: start,
          done: bool,
        };
      },
    };
    return iterator;
  }
  /**
  @memberof DiscreteRange
  @method prev
  @description Decrement the given value with the step defined for this class.
  @param {scalar} curr -Value to decrement
  @returns {scalar}
  */
  prev(curr, step, type) {
    if (type === 'date') { return curr.subtract(1, step); }
    return curr - this.step;
  }
  /**
  @memberof DiscreteRange
  @method last
  @description Returns the last element within this range. If the range has no
  upper limit, `null` is returned.
  @returns {scalar}
  */
  last() {
    if (!this || !this.upper) {
      return null;
    }
    return this.prev(this.upper, this.step, this.type);
  }

  endsWith(other) {
    // Discrete ranges have a lst element even in cases where the UB is null
    if (this.isValidScalar(other)) {
      return this.last() === other;
    }
    return super.endsWith(other);
  }
}

class IntRange extends DiscreteRange {
  /**
  @class IntRange
  @extends DiscreteRange
  @description Range that operates on int.
  @param {object} settings - The settings of the range.
  @param {int} [settings.lower=null] - The lower end of the range
  @param {int} [settings.upper=null] - The upper end of the range
  @param {boolean} [settings.lowerInc=true] - ``true`` if lower end should be included in range.
  @param {boolean} [settings.upperInc=false] ``true`` if upper end should be included in range.
  @mixes OffsetableRangeMixin
  */
  constructor(settings = {}) {
    settings.type = 'int';
    super(1, settings);
    Object.assign(this, utils.OffsetableRangeMixin);
    /**
    @memberof IntRange
    @description The type of values in the range.
    */
    this.type = settings.type;
  }
  /**
  @memberof IntRange
  @method length
  @description Return the length of the range
  @returns {scalar}
  */
  length() {
    return this.upper - this.lower;
  }
}

class StrRange extends DiscreteRange {
  /**
  @class StrRange
  @extends DiscreteRange
  @description Range that operates on strings.
  @param {object} settings - The settings of the range.
  @param {string} [settings.lower=null] - The lower end of the range
  @param {string} [settings.upper=null] - The upper end of the range
  @param {boolean} [settings.lowerInc=true] - ``true`` if lower end should be included in range.
  @param {boolean} [settings.upperInc=false] ``true`` if upper end should be included in range.
  */
  constructor(settings = {}) {
    settings.type = 'ustr';
    super(1, settings);
    /**
    @memberof StrRange
    @description The type of values in the range.
    */
    this.type = settings.type;
  }
  /**
  @memberof StrRange
  @method next
  @description Increment the given value with the step defined for this class.
  @param {string} curr - Value to increment
  @returns {scalar}
  */
  next(curr) {
    if (!curr) {
      return '';
    }
    const last = curr.substr(curr.length - 1);

    if (last.charCodeAt() === 65535) {
      return this.next(curr.slice(0, -1)) + String.fromCharCode(0);
    }
    return curr.slice(0, -1) + String.fromCharCode(last.charCodeAt() + 1);
  }
  /**
  @memberof StrRange
  @method prev
  @description decrement the given value with the step defined for this class.
  @param {string} curr - Value to decrement
  @returns {string}
  */
  prev(curr) {
    if (!curr) {
      return '';
    }

    const last = curr.substr(curr.length - 1);

    if (last.charCodeAt() === 0) {
      return this.prev(curr.slice(0, -1)) + String.fromCharCode(65535);
    }
    return curr.slice(0, -1) + String.fromCharCode(last.charCodeAt() - 1);
  }
}

class DateRange extends DiscreteRange {
  /**
  @class DateRange
  @extends DiscreteRange
  @description Range that operates on dates.
  @param {object} settings - The settings of the range.
  @param {string} [settings.lower=null] - The lower end of the range -
  Formatted as either 'YYYY-MM-DD' or 'MM-DD-YYYY'
  @param {string} [settings.upper=null] - The upper end of the range -
   Formatted as either 'YYYY-MM-DD' or 'MM-DD-YYYY'
  @param {boolean} [settings.lowerInc=true] - ``true`` if lower
  end should be included in range.
  @param {boolean} [settings.upperInc=false] ``true`` if upper
  end should be included in range.
  */

  constructor(settings = {}) {
    if (Object.keys(settings).length !== 0 &amp;&amp; settings.lower &amp;&amp;
                                      !utils.isValidDate(settings.lower)) {
      throw new Error('Invalid type of lower bound');
    }

    if (Object.keys(settings).length !== 0 &amp;&amp; settings.upper &amp;&amp;
                                      !utils.isValidDate(settings.upper)) {
      throw new Error('Invalid type of upper bound');
    }
    settings.type = 'date';
    super('day', settings);
    /**
    @memberof DateRange
    @description The type of values in the range.
    */
    this.type = settings.type;
    Object.assign(this, utils.OffsetableRangeMixin);
    this.offsetType = 'duration';
    /**
    @memberof DateRange
    @description How far to step when iterating.
    */
    this.step = 'day';
  }

  /**
  @memberof DateRange
  @method fromDate
  @description Returns a DateRange with length period beginning at date.
  @param {string} date A date to begin the range from.
  Formatted as either 'YYYY-MM-DD' or 'MM-DD-YYYY'
  @param {string} [period='day'] How long the range should be.
  Options: 'day', 'week', 'month', 'quarter', 'year'
  @returns {range}
  */

  fromDate(date, period = 'day') {
    let start;
    if (period === 'day') {
      return new DateRange({ lower: date, upper: date, upperInc: true });
    }
    if (period === 'week') {
      date = moment(date, 'MM-DD-YYYY').isValid() ? moment(date, 'MM-DD-YYYY') : moment(date, 'YYYY-MM-DD');
      let subtract = date.day() - 1;
      if (date.day() === 0) {
        subtract = 6;
      } else if (date.day() === 1) { subtract = 1; }
      start = date.subtract(subtract, 'days');
      return new DateRange({ lower: start.format('YYYY-MM-DD'), upper: start.add(1, 'week').format('YYYY-MM-DD') });
    }
    if (period === 'americanWeek') {
      date = moment(date, 'MM-DD-YYYY').isValid() ? moment(date, 'MM-DD-YYYY') : moment(date, 'YYYY-MM-DD');
      start = date.subtract(date.day(), 'days');
      return new DateRange({ lower: start.format('YYYY-MM-DD'), upper: start.add(1, 'week').format('YYYY-MM-DD') });
    }
    if (period === 'month') {
      date = moment(date, 'MM-DD-YYYY').isValid() ? moment(date, 'MM-DD-YYYY') : moment(date, 'YYYY-MM-DD');
      start = date.date(1);
      return new DateRange({ lower: start.format('YYYY-MM-DD'), upper: start.add(1, 'month').date(1).format('YYYY-MM-DD') });
    }
    if (period === 'quarter') {
      date = moment(date, 'MM-DD-YYYY').isValid() ? moment(date, 'MM-DD-YYYY') : moment(date, 'YYYY-MM-DD');
      start = date.month(Math.floor(date.month() / 3) * 3).date(1);
      return new DateRange({ lower: start.format('YYYY-MM-DD'), upper: start.add(3, 'month').date(1).format('YYYY-MM-DD') });
    }
    if (period === 'year') {
      date = moment(date, 'MM-DD-YYYY').isValid() ? moment(date, 'MM-DD-YYYY') : moment(date, 'YYYY-MM-DD');
      start = date.month(0).date(1);
      return new DateRange({ lower: start.format('YYYY-MM-DD'), upper: start.add(1, 'year').format('YYYY-MM-DD') });
    }
    throw new Error('Unexpected period.');
  }
  /**
  @memberof DateRange
  @method length
  @description Return the length of the range
  @returns {scalar}
  */
  length() {
    if (!this.upper || !this.lower) {
      throw new Error('Unbounded ranges do not have a length');
    }
    return Math.round(moment.duration(this.upper.diff(this.lower)).asDays());
  }
}

class PeriodRange extends DateRange {
  constructor(settings = {}) {
    super(settings);
  }

  fromDate(day, period = 'day') {
    const span = new DateRange().fromDate(day, period);
    const newSpan = new PeriodRange();
    newSpan._range = span._range;
    newSpan.period = period;
    return newSpan;
  }

  empty() {
    throw new Error('PeriodRange does not support empty ranges');
  }

  get daterange() {
    return new DateRange({
      lower: this.lower,
      upper: this.upper,
      lowerInc: this.lowerInc,
      upperInc: this.upperInc,
    });
  }

  isValidRange(other) {
    return other instanceof DateRange;
  }

  replace(settings) {
    return this.daterange.replace(settings);
  }
}

module.exports = {
  IntRange,
  StrRange,
  DateRange,
  PeriodRange,
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Jun 12 2017 14:59:08 GMT+1000 (AUS Eastern Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
